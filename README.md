# Intervue Live Polling System

A real-time, interactive Live Polling System built to connect Teachers and Students via seamless live web socket communication. The platform allows educators to create real-time questionnaires, broadcast them instantly to active participants, monitor live visual results, manage classroom participants, and review historical polling data. 

**Note:** This application was developed to strictly mirror high-fidelity Figma mockups, implementing an interactive, pixel-perfect frontend coupled tightly with a robust, scalable backend architecture.

---

## ðŸš€ Features

* **Role-Based Workspaces**: Users securely identify themselves as either a **Teacher** or **Student** prior to entering the poll room.
* **Real-time Live Polling**:
  * Teachers can actively author polls with dynamic durations (10s, 30s, 60s, 90s) and multiple options, while defining precise correct answers.
  * Students natively receive the broadcast and make a single, verified selection.
  * The frontend dynamically renders live percentage shifts and visually alerts users with a synchronized countdown timer.
* **Live Chat & Participant Management**:
  * Persistent, built-in global chat system connecting the classroom.
  * Teachers possess an exclusive **Participants Tab** allowing them to monitor active student IDs and explicitly **Kick out** disruptive accounts in real-time. (Students instantly receive a full-screen notice upon removal).
* **Poll History & Analytics**:
  * Teachers can quickly toggle to view all natively completed polls containing exact voting ratios and participant aggregates.
  * Upon poll expiration, Students are forcibly redirected to a locked Final Results screen to review correct analytics alongside their peers.

---

## ðŸ§© Project Architecture

The project is structured entirely as a Monorepo containing decoupled Client (Frontend) and Server (Backend) domains. 

### **Backend (Node.js/Express)**
Implemented utilizing a refined **Controller-Service Architecture** to aggressively separate business logic from socket/route handling.

```text
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/             # DB initialization & Environment parsing (Mongoose setup)
â”‚   â”œâ”€â”€ middlewares/        # Express global error handlers & HTTP intercepts
â”‚   â”œâ”€â”€ modules/            
â”‚   â”‚   â””â”€â”€ poll/           # Encapsulated Polling Module
â”‚   â”‚       â”œâ”€â”€ poll.model.ts      # Mongoose Database Schema
â”‚   â”‚       â”œâ”€â”€ poll.service.ts    # Core Business Logic (DB reads/writes, constraints)
â”‚   â”‚       â”œâ”€â”€ poll.controller.ts # REST API bindings
â”‚   â”‚       â””â”€â”€ poll.socket.ts     # Real-time WebSocket Event Handlers (Join/Vote/Kick)
â”‚   â”œâ”€â”€ routes/             # REST Route Definitions (binds to Controllers)
â”‚   â””â”€â”€ server.ts           # Primary Express & Socket.io App Initialization
```

### **Frontend (React/Vite)**
Built via a modern component-based architecture relying heavily on Custom React Hooks to decouple UX from complex rendering lifecycles.

```text
frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/         # Reusable structural UI (ChatBox, PollHistorySection)
â”‚   â”œâ”€â”€ hooks/              # Custom Logic Containers
â”‚   â”‚   â”œâ”€â”€ useSocket.ts    # Global Singleton WebSocket Management Strategy
â”‚   â”‚   â”œâ”€â”€ usePollTimer.ts # RequestAnimationFrame/Interval syncing for countdowns
â”‚   â”‚   â””â”€â”€ usePollRecovery.ts # API syncing to restore app state on sudden refresh
â”‚   â”œâ”€â”€ pages/              # Primary Route Views
â”‚   â”‚   â”œâ”€â”€ RoleSelectPage.tsx # Initial Gateway
â”‚   â”‚   â”œâ”€â”€ StudentPage.tsx    # Live Voting & Analytics 
â”‚   â”‚   â””â”€â”€ TeacherPage.tsx    # Control Dashboard & Creation Engine
â”‚   â””â”€â”€ App.tsx             # React Router Configuration & Provider boundaries
```

---

## ðŸ—„ï¸ Database Design

The system maps data persistently via **MongoDB** employing a unified `Poll` document structure optimized for NoSQL read-heavy WebSocket deployments.

**`Polls` Collection schema:**
* `_id`: ObjectId (Auto-generated by Mongo)
* `question`: String (Required, trimmed)
* `options`: Array of Objects
  * `text`: String (Option Label)
  * `votes`: Number (Auto-tallying integer, Default `0`)
* `duration`: Number (Lifespan in seconds)
* `startTime`: Date (Timestamp capturing when the poll went 'Live')
* `status`: Enum String (`'active'` | `'completed'`) - *Indexed for rapid querying*
* `voters`: Array of Objects *(Maintains vote integrity / Prevents double-casting)*
  * `studentId`: String (Unique identifier/name of the participant)
  * `selectedOptionIndex`: Number (Maps to the `options` array index they chose)
* `createdAt` / `updatedAt`: Timestamps

---

## ðŸ›  Tech Stack & Dependencies

**Frontend Environment:**
* React 18 (TypeScript)
* Vite (Bundler & Dev Server)
* `react-router-dom` (v7 Routing Navigation)
* `socket.io-client` (v4.8 Real-time events)
* *Vanilla CSS & Custom Context Properties* (Purposely chosen to perfectly map custom Figma designs without battling framework opinionation)

**Backend Environment:**
* Node.js (via `tsx` TypeScript execution)
* Express.js (v5.2 REST APIs)
* `socket.io` (v4.8 WebSocket Engine)
* MongoDB & `mongoose` (v9.2 ODM Data Mapping)
* `cors` & `dotenv` (Environment integration)

---

## ðŸ’» Running the Application Locally

### Prerequisites
* **Node.js**: `v18.0` or higher recommended
* **MongoDB**: A running local instance (`mongodb://127.0.0.1:27017`) or Cloud Atlas URI

### 1. Starting the Backend Server
```bash
cd backend
npm install

# The application utilizes dotenv. Create a basic `.env` file in the backend root:
# echo "MONGO_URI=mongodb://127.0.0.1:27017/poll-system" > .env
# echo "PORT=3000" >> .env
# echo "FRONTEND_URL=http://localhost:5173" >> .env

# Start the tsx watch server
npm run dev
```

### 2. Starting the Frontend Client
```bash
cd frontend
npm install

# Start the Vite development server
npm run dev
```

*(By default, the Vite application will operate on port `5173` and automatically bind to the backend socket initializing on port `3000`)*
